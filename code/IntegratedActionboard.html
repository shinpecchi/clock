import React, { useState, useEffect, useRef, useMemo, useCallback } from 'react';
import { Plus, CheckCircle, Clock, Trash2, Play, Pause, Edit3, X, Save, Calendar, Star, Loader2, Target, Trophy, AlertTriangle, RotateCcw } from 'lucide-react';

// --- ヘルパー関数 ---

// "HH:MM" 文字列をその日の0:00からの分（number）に変換
const timeToMinutes = (timeStr) => {
  if (!timeStr) return null;
  const [h, m] = timeStr.split(':').map(Number);
  return h * 60 + m;
};

// 分（number）を "HH:MM" 文字列に変換
const minutesToTime = (totalMinutes) => {
  if (totalMinutes === null || totalMinutes === undefined) return '';
  // 24時間以上も対応できるように計算
  const h = Math.floor(totalMinutes / 60);
  const m = totalMinutes % 60;
  return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
};

// 経過時間 (秒) を HH:MM:SS または MM:SS にフォーマット
const formatDuration = (seconds) => {
  const h = Math.floor(seconds / 3600);
  const m = Math.floor((seconds % 3600) / 60);
  const s = seconds % 60;
  if (h > 0) return `${h}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
  return `${m}:${s.toString().padStart(2, '0')}`;
};

// 重なりを計算してレイアウト情報(width, left)を付与するアルゴリズム
const calculateLayout = (tasks) => {
  const scheduledTasks = tasks
    .filter(t => t.scheduledTime)
    .map(t => {
      const start = timeToMinutes(t.scheduledTime);
      const duration = t.status === 'done' ? (t.actualMin || t.estimatedMin) : t.estimatedMin;
      return { 
        ...t, 
        start, 
        end: start + duration,
        duration 
      };
    })
    .sort((a, b) => a.start - b.start);

  // タイムラインのレイアウト処理（前のファイルから流用・簡略化）
  const layoutedTasks = [];
  scheduledTasks.forEach(task => {
    // 完全に重なっているタスクを検出
    const overlaps = scheduledTasks.filter(other => 
      task.id !== other.id && 
      other.start < task.end && 
      other.end > task.start
    );

    // グループ内のタスク数と自分のインデックスに基づいて幅と位置を決定
    const group = [task, ...overlaps].sort((a, b) => a.start - b.start || a.id - b.id);
    const count = group.length;
    const index = group.findIndex(t => t.id === task.id);

    const width = 100 / count;
    const left = width * index;

    layoutedTasks.push({
      ...task,
      width,
      left
    });
  });

  return layoutedTasks;
};

// --- コンポーネント: 紙吹雪エフェクト (簡易版) ---
const Confetti = () => (
  <div className="fixed inset-0 pointer-events-none z-50 flex items-center justify-center overflow-hidden">
    {[...Array(20)].map((_, i) => (
      <div
        key={i}
        className="absolute w-3 h-3 rounded-full animate-confetti"
        style={{
          left: `${Math.random() * 100}%`,
          top: `-10%`,
          animationDuration: `${2 + Math.random() * 3}s`,
          animationDelay: `${Math.random()}s`,
          backgroundColor: ['#fbbf24', '#f87171', '#60a5fa', '#34d399'][Math.floor(Math.random() * 4)]
        }}
      />
    ))}
  </div>
);


// --- メインコンポーネント: Action Board ---
const ActionBoard = () => {
  // --- State管理 ---
  const [tasks, setTasks] = useState([
    { id: 1, title: '朝会・チェックイン', category: 'ミーティング', estimatedMin: 30, actualMin: 30, status: 'done', scheduledTime: '09:00', kpt: { k: '定刻通り開始', p: '回線が不安定だった', t: '有線接続を試す' }, elapsed: 1800 },
    { id: 2, title: '資料作成集中タイム', category: '作業', estimatedMin: 60, actualMin: 0, status: 'todo', scheduledTime: '10:00', kpt: { k: '', p: '', t: '' }, elapsed: 0 },
    { id: 3, title: 'メール返信', category: 'ルーチン', estimatedMin: 15, actualMin: 0, status: 'todo', scheduledTime: '10:30', kpt: { k: '', p: '', t: '' }, elapsed: 0 },
    { id: 4, title: 'ユーザーヒアリング準備', category: '企画', estimatedMin: 90, actualMin: 0, status: 'doing', scheduledTime: '13:30', kpt: { k: '', p: '', t: '' }, elapsed: 300 },
    { id: 5, title: 'リマインド確認', category: '雑務', estimatedMin: 5, actualMin: 0, status: 'todo', scheduledTime: '10:20', kpt: { k: '', p: '', t: '' }, elapsed: 0 },
  ]);

  const [activeTaskId, setActiveTaskId] = useState(null);
  const [currentTime, setCurrentTime] = useState(new Date());
  
  // モーダル関連
  const [isEditModalOpen, setIsEditModalOpen] = useState(false);
  const [isGoalModalOpen, setIsGoalModalOpen] = useState(true);
  const [isKptModalOpen, setIsKptModalOpen] = useState(false);
  const [isDeleteConfirmOpen, setIsDeleteConfirmOpen] = useState(false);
  
  const [editingTask, setEditingTask] = useState(null); // 編集中のタスク（新規含む）
  const [completingTask, setCompletingTask] = useState(null); // 完了直後のKPT入力用タスク
  const [targetPoints, setTargetPoints] = useState(180); // 目標ポイント（分）
  const timerInterval = useRef(null);

  // --- 計算ロジック ---
  const totalPoints = useMemo(() => tasks
    .filter(t => t.status === 'done')
    .reduce((sum, t) => sum + (t.actualMin || 0), 0), [tasks]);

  const calendarTasks = useMemo(() => calculateLayout(tasks), [tasks]);

  // --- Effect: 現在時刻とタイマー ---
  // 1秒ごとに現在時刻とタイマーを更新
  useEffect(() => {
    const clockTimer = setInterval(() => setCurrentTime(new Date()), 1000);
    return () => clearInterval(clockTimer);
  }, []);

  useEffect(() => {
    if (activeTaskId) {
      timerInterval.current = setInterval(() => {
        setTasks(prev => prev.map(t => {
          if (t.id === activeTaskId) {
            return { ...t, elapsed: (t.elapsed || 0) + 1 };
          }
          return t;
        }));
      }, 1000);
    } else {
      clearInterval(timerInterval.current);
    }
    return () => clearInterval(timerInterval.current);
  }, [activeTaskId]);


  // --- タスク編集モーダル制御 ---
  const openEditModal = useCallback((task = null) => {
    if (task) {
      // 既存タスク編集
      setEditingTask({ ...task });
      setIsEditModalOpen(true);
    } else {
      // 新規作成
      const nowMin = currentTime.getHours() * 60 + currentTime.getMinutes();
      setEditingTask({
        id: null,
        title: '',
        category: '一般',
        estimatedMin: 30,
        actualMin: 0,
        startTime: minutesToTime(nowMin + 5), // 現在時刻の5分後を初期設定
        scheduledTime: minutesToTime(nowMin + 5),
        kpt: { k: '', p: '', t: '' },
        status: 'todo',
        elapsed: 0,
      });
      setIsEditModalOpen(true);
    }
  }, [currentTime]);

  const closeEditModal = () => {
    setIsEditModalOpen(false);
    setEditingTask(null);
  };
  
  // --- KPTモーダル制御 ---
  const openKptModal = (task) => {
    setIsEditModalOpen(false); // 編集モーダルを閉じる
    setCompletingTask(task);
    setIsKptModalOpen(true);
  };

  const closeKptModal = () => {
    setIsKptModalOpen(false);
    setCompletingTask(null);
  }

  // --- アクションハンドラ ---
  
  const handleSaveTask = (e) => {
    e.preventDefault();
    if (!editingTask.title || !editingTask.estimatedMin) return;

    const newTaskData = {
      ...editingTask,
      estimatedMin: Number(editingTask.estimatedMin),
      actualMin: Number(editingTask.actualMin)
    };

    setTasks(prevTasks => {
      if (editingTask.id) {
        return prevTasks.map(t => t.id === editingTask.id ? newTaskData : t);
      } else {
        // 新規追加
        return [...prevTasks, { ...newTaskData, id: Date.now() }];
      }
    });
    
    closeEditModal();
  };

  const toggleTimer = (id) => {
    if (activeTaskId === id) {
      setActiveTaskId(null); // 中断
    } else {
      if (activeTaskId) setActiveTaskId(null); // 他のタスクを停止

      setActiveTaskId(id); // 開始
      setTasks(prev => prev.map(t => t.id === id && t.status !== 'doing' ? { ...t, status: 'doing' } : t));
    }
  };

  // 完了ボタンを押した時の処理 -> KPTモーダルへ
  const initCompleteTask = (task) => {
    setActiveTaskId(null); // タイマー停止
    const finalMinutes = Math.ceil((task.elapsed || 0) / 60);
    const newActualMin = finalMinutes > 0 ? finalMinutes : task.estimatedMin;

    // KPT入力を促すため、自動的にモーダルを開く準備
    const taskForKPT = {
      ...task,
      status: 'done',
      actualMin: newActualMin, // 実績時間を確定
    };
    
    setCompletingTask(taskForKPT);
    openKptModal(taskForKPT);
  };

  // KPT入力後の最終確定
  const finalizeKpt = (kptData) => {
    if (!completingTask) return;

    setTasks(tasks.map(t => 
      t.id === completingTask.id ? { 
        ...completingTask, // initCompleteTaskで更新された actualMin を含む
        kpt: kptData,
      } : t
    ));

    closeKptModal();
  };
  
  const resetTask = (id) => {
     setTasks(prevTasks => prevTasks.map(t => 
        t.id === id ? { 
          ...t, 
          kpt: { k: '', p: '', t: '' }, 
          status: 'todo', 
          actualMin: 0, 
          elapsed: 0 
        } : t
     ));
     setIsEditModalOpen(false);
  }

  // --- UIコンポーネント: プログレスバー ---
  const ProgressBar = () => {
    const progress = Math.min((totalPoints / targetPoints) * 100, 100);
    return (
      <div className="w-full bg-slate-200 rounded-full h-2.5 overflow-hidden shadow-inner">
        <div 
          className="h-full bg-gradient-to-r from-green-400 to-emerald-500 transition-all duration-1000 ease-out"
          style={{ width: `${progress}%` }}
        />
      </div>
    );
  };

  // --- UIコンポーネント: タスクカード (リスト形式) ---
  const TaskListItem = ({ task }) => {
    const isRunning = activeTaskId === task.id;
    const isDone = task.status === 'done';

    // 予定時間帯
    const durationMin = isDone ? (task.actualMin || 0) : task.estimatedMin;
    const startMin = timeToMinutes(task.scheduledTime);
    const endMin = startMin ? startMin + durationMin : null;
    const timeRange = task.scheduledTime 
        ? `${task.scheduledTime} - ${endMin ? minutesToTime(endMin) : '未定'}`
        : `${task.estimatedMin}分`;
    
    // アイコンと色
    let statusIcon = <Clock size={12} className="text-blue-400" />;
    let statusBg = "bg-blue-100";
    if (isRunning) {
        statusIcon = <Loader2 size={12} className="text-orange-500 animate-spin" />;
        statusBg = "bg-orange-100";
    }
    if (isDone) {
        statusIcon = <CheckCircle size={12} className="text-green-500" />;
        statusBg = "bg-green-100";
    }
    
    const rowClass = isRunning ? "bg-yellow-50 shadow-md ring-2 ring-yellow-200" : (isDone ? "bg-slate-50 opacity-80" : "bg-white hover:bg-slate-50");

    return (
      <div 
        className={`flex items-center p-3 rounded-lg border border-slate-100 cursor-pointer transition-all ${rowClass}`}
      >
        <div 
          onClick={(e) => { e.stopPropagation(); openEditModal(task); }}
          className={`p-1 rounded-full ${statusBg} mr-2 flex-shrink-0`}
        >
          {statusIcon}
        </div>
        
        <div className="flex-1 min-w-0" onClick={() => openEditModal(task)}>
          <div className="text-xs text-slate-500 font-mono flex items-center gap-2">
            <span className="font-bold">{timeRange}</span>
            {isRunning && (
                <span className="text-orange-600 font-mono text-xs ml-auto">
                    ({formatDuration(task.elapsed)})
                </span>
            )}
            {isDone && (
                <span className="text-green-600 font-bold text-xs ml-auto">
                    {task.actualMin} pt
                </span>
            )}
          </div>
          <h4 className="font-bold text-slate-800 truncate text-sm">{task.title}</h4>
        </div>
        
        {/* 中断/開始/完了ボタン: 完了タスクでは表示しない */}
        {!isDone && (
          <div className="flex gap-2 ml-2 flex-shrink-0">
             <button 
                onClick={(e) => { e.stopPropagation(); isRunning ? initCompleteTask(task) : toggleTimer(task.id); }}
                className={`p-2 rounded-full text-white transition-all flex-shrink-0 shadow ${isRunning ? 'bg-green-600 hover:bg-green-700' : 'bg-blue-500 hover:bg-blue-600'}`}
                title={isRunning ? '完了してKPTへ' : '実行開始'}
             >
                {isRunning ? <CheckCircle size={14} /> : <Play size={14} />}
             </button>
             {isRunning && (
                <button 
                    onClick={(e) => { e.stopPropagation(); toggleTimer(task.id); }}
                    className={`p-2 rounded-full text-white transition-all flex-shrink-0 shadow bg-orange-500 hover:bg-orange-600`}
                    title={'中断'}
                >
                    <Pause size={14} />
                </button>
             )}
          </div>
        )}
      </div>
    );
  };

  // --- UIコンポーネント: カレンダータイムライン ---
  const START_HOUR = 0; // 0:00 開始
  const END_HOUR = 24; // 24:00 終了
  const HOUR_HEIGHT = 70; // 1時間の高さ(px)

  const CalendarTimeline = () => {
    // 現在時刻のY座標計算
    const nowMin = currentTime.getHours() * 60 + currentTime.getMinutes() + currentTime.getSeconds() / 60;
    const startMin = START_HOUR * 60;
    const offsetMin = nowMin - startMin;
    const currentLineTop = (offsetMin / 60) * HOUR_HEIGHT;

    return (
      <div className="relative border-l border-slate-200 ml-14 h-full bg-white/50 rounded-l-xl md:rounded-l-none overflow-hidden shadow-inner p-2">
        {/* グリッド線と時間ラベル (0:00 - 23:00) */}
        {Array.from({ length: END_HOUR - START_HOUR }).map((_, i) => { 
          const hour = START_HOUR + i;
          return (
            <div key={hour} className="absolute w-full border-t border-slate-200/60" style={{ top: i * HOUR_HEIGHT }}>
              {/* 時間ラベル */}
              <span className="absolute -left-14 -top-2 text-xs font-bold text-slate-400 w-12 text-right">
                {hour.toString().padStart(2, '0')}:00
              </span>
            </div>
          );
        })}

        {/* 現在時刻バー (リアルタイム移動) */}
        {currentLineTop >= 0 && currentLineTop <= (END_HOUR - START_HOUR) * HOUR_HEIGHT && (
          <div 
            className="absolute w-full border-t-2 border-red-500 z-10 pointer-events-none flex items-center transition-transform duration-100 ease-linear"
            style={{ top: `${currentLineTop}px` }}
          >
            <div className="absolute -left-1 w-2 h-2 bg-red-500 rounded-full" />
          </div>
        )}

        {/* タスクブロック */}
        {calendarTasks.map(task => {
          const offsetMin = task.start - startMin;
          const top = (offsetMin / 60) * HOUR_HEIGHT;
          const height = (task.duration / 60) * HOUR_HEIGHT;
          
          let bgClass = "bg-blue-500 text-white";
          if (task.status === 'doing') bgClass = "bg-orange-500 text-white shadow-lg shadow-orange-300/50";
          if (task.status === 'done') bgClass = "bg-slate-300 text-slate-700 opacity-90";

          return (
            <div
              key={task.id}
              onClick={() => openEditModal(task)}
              className={`absolute px-2 py-1 rounded-md text-xs font-bold shadow cursor-pointer hover:shadow-xl transition-all overflow-hidden ${bgClass}`}
              style={{
                top: `${top}px`,
                height: `${Math.max(20, height)}px`,
                left: `${task.left}%`,
                width: `${task.width}%`,
                zIndex: task.status === 'doing' ? 20 : 10
              }}
            >
              <span className="truncate block leading-tight">{task.title}</span>
              {height > 30 && (
                <div className="text-[10px] font-normal opacity-90 leading-tight">
                  {task.scheduledTime} - {minutesToTime(task.end)}
                </div>
              )}
            </div>
          );
        })}
      </div>
    );
  };

  // --- UIコンポーネント: デジタル時計 ---
  const CurrentTimeClock = () => {
    const timeOptions = { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false };
    const dateOptions = { month: '2-digit', day: '2-digit', weekday: 'short' };
    
    const timeStr = currentTime.toLocaleTimeString('ja-JP', timeOptions);
    const dateStr = currentTime.toLocaleDateString('ja-JP', dateOptions);

    return (
      <div className="p-5 border-b border-slate-100 bg-white">
        <div className="text-sm text-slate-500 mb-1">{dateStr}</div>
        <div className="text-4xl font-bold font-mono text-slate-800 leading-none">{timeStr}</div>
        <div className="flex items-center gap-4 mt-3 text-xs text-slate-400">
          <div className="flex items-center gap-1">
            <Clock size={12} className="text-blue-400" />
            <span className='font-bold text-slate-600'>現在時刻</span>
          </div>
          <div className="flex items-center gap-1">
            <Target size={12} className="text-green-500" />
            <span className='font-bold text-slate-600'>{totalPoints} pt 達成 (目標: {targetPoints} pt)</span>
          </div>
        </div>
      </div>
    );
  };
  
  // --- レンダー ---

  return (
    <div className="min-h-screen flex flex-col bg-slate-100 font-sans text-slate-800 overflow-hidden">
      {totalPoints >= targetPoints && <Confetti />}
      
      {/* ヘッダー/目標プログレス */}
      <header className="bg-white/95 backdrop-blur-md border-b border-slate-200 z-20 flex-shrink-0">
        <div className="max-w-7xl mx-auto px-4 py-3">
          <div className="flex items-center justify-between mb-2">
            <h1 className="font-bold text-lg text-slate-800">
              アクションボード (統合版)
            </h1>
            
            <div className="flex items-center gap-4">
              <div className="text-right">
                <div className="text-xs text-slate-500 font-bold">TODAY'S SCORE</div>
                <div className="flex items-baseline gap-1">
                  <span className={`text-xl font-black font-mono ${totalPoints >= targetPoints ? 'text-red-500' : 'text-slate-800'}`}>
                    {totalPoints}
                  </span>
                  <span className="text-xs text-slate-400 font-bold">/ {targetPoints} pt</span>
                </div>
              </div>
              <button 
                onClick={() => setIsGoalModalOpen(true)}
                className="bg-slate-100 hover:bg-slate-200 p-2 rounded-full transition-colors"
                title="目標を編集"
              >
                <Trophy size={16} className="text-slate-600" />
              </button>
              <button 
                onClick={() => openEditModal()}
                className="bg-blue-600 text-white px-4 py-2 rounded-full font-bold shadow-md hover:bg-blue-700 transition-colors flex items-center gap-2 text-sm"
              >
                <Plus size={16} /> タスク追加
              </button>
            </div>
          </div>
          <ProgressBar />
        </div>
      </header>

      {/* メインエリア: PC(横並び) / Mobile(縦積み) - 中央寄せ */}
      <div className="flex-1 flex justify-center w-full p-4 overflow-y-auto">
        <main className="flex flex-col md:flex-row max-w-7xl w-full bg-white rounded-xl shadow-lg">
        
          {/* 左側/上側: タスクリスト + 時計 */}
          <div className="w-full md:w-[400px] flex-shrink-0 border-b md:border-b-0 md:border-r border-slate-200 overflow-y-auto">
            
            {/* デジタル時計 */}
            <CurrentTimeClock />

            <div className="p-5 space-y-4">
              
              {/* 実行中 */}
              {tasks.filter(t => t.status === 'doing').length > 0 && (
                <div>
                  <h3 className="font-bold text-orange-500 flex items-center gap-2 mb-2">
                    <Loader2 size={16} className="animate-spin" />
                    実行中 ({tasks.filter(t => t.status === 'doing').length})
                  </h3>
                  <div className="space-y-2">
                    {tasks.filter(t => t.status === 'doing').map(task => (
                      <TaskListItem key={task.id} task={task} />
                    ))}
                  </div>
                </div>
              )}
              
              {/* 未着手 */}
              <div>
                <h3 className="font-bold text-slate-500 flex items-center gap-2 mb-2">
                  <Clock size={16} className="text-slate-400" />
                  未着手タスク ({tasks.filter(t => t.status === 'todo').length})
                </h3>
                <div className="space-y-2">
                  {tasks.filter(t => t.status === 'todo').sort((a,b) => timeToMinutes(a.scheduledTime) - timeToMinutes(b.scheduledTime)).map(task => (
                    <TaskListItem key={task.id} task={task} />
                  ))}
                </div>
              </div>

              {/* 完了タスク */}
              <div>
                <h3 className="font-bold text-green-600 flex items-center gap-2 mt-6 mb-2">
                  <CheckCircle size={16} />
                  完了タスク ({tasks.filter(t => t.status === 'done').length})
                </h3>
                <div className="space-y-2">
                  {tasks.filter(t => t.status === 'done').map(task => (
                    <TaskListItem key={task.id} task={task} />
                  ))}
                </div>
              </div>
            </div>
          </div>

          {/* 右側/下側: カレンダータイムライン */}
          <div className="flex-1 overflow-y-auto bg-slate-50 relative p-5">
            <div className="font-bold text-slate-700 flex items-center gap-2 mb-4">
              <Calendar size={18} /> スケジュールタイムライン (0:00 - 24:00)
            </div>
            {/* カレンダーの縦幅を確保: 24時間 * 70px/時間 = 1680px */}
            <div className="h-[1700px] relative">
              <CalendarTimeline />
            </div>
          </div>

        </main>
      </div>
      
      {/* モーダル群 */}

      {/* 1. タスク編集/新規作成モーダル */}
      {isEditModalOpen && editingTask && (
        <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-slate-900/50 backdrop-blur-sm animate-fade-in">
          <div className="bg-white rounded-2xl shadow-2xl w-full max-w-lg overflow-hidden animate-slide-up flex flex-col max-h-[90vh]">
            
            {/* モーダルヘッダー */}
            <div className="px-6 py-4 border-b border-slate-100 flex justify-between items-center bg-blue-600 text-white flex-shrink-0">
              <h3 className="font-bold text-lg flex items-center gap-2">
                <Edit3 size={18} />
                {editingTask.id ? 'タスクを編集' : '新しいタスクを追加'}
              </h3>
              <button onClick={closeEditModal} className="text-blue-200 hover:text-white">
                <X size={20} />
              </button>
            </div>

            {/* モーダルコンテンツ (スクロール可能) */}
            <div className="p-6 overflow-y-auto custom-scrollbar flex-1">
              <form id="taskForm" onSubmit={handleSaveTask} className="space-y-6">
                
                {/* 基本情報 */}
                <div className="grid gap-4 pt-2">
                  <div>
                    <label className="block text-xs font-bold text-slate-500 mb-1">タスク名</label>
                    <input 
                      required
                      value={editingTask.title}
                      onChange={e => setEditingTask({...editingTask, title: e.target.value})}
                      className="w-full px-4 py-2 rounded-lg border border-slate-200 focus:ring-2 focus:ring-blue-100 outline-none font-bold text-slate-800"
                      placeholder="例: プレゼン資料作成"
                    />
                  </div>
                  <div className="grid grid-cols-3 gap-4">
                     <div>
                       <label className="block text-xs font-bold text-slate-500 mb-1">カテゴリー</label>
                       <select 
                         value={editingTask.category}
                         onChange={e => setEditingTask({...editingTask, category: e.target.value})}
                         className="w-full px-4 py-2 rounded-lg border border-slate-200 outline-none bg-white"
                       >
                         <option>一般</option>
                         <option>ミーティング</option>
                         <option>作業</option>
                         <option>ルーチン</option>
                         <option>企画</option>
                         <option>雑務</option>
                       </select>
                     </div>
                     <div>
                       <label className="block text-xs font-bold text-slate-500 mb-1">ステータス</label>
                       <select 
                         value={editingTask.status}
                         onChange={e => setEditingTask({...editingTask, status: e.target.value})}
                         className="w-full px-4 py-2 rounded-lg border border-slate-200 outline-none bg-white"
                         disabled={editingTask.id === activeTaskId} // 実行中はステータス変更不可
                       >
                         <option value="todo">未着手</option>
                         <option value="doing">実行中</option>
                         <option value="done">完了</option>
                       </select>
                     </div>
                     <div>
                       <label className="block text-xs font-bold text-slate-500 mb-1">経過時間 (秒)</label>
                       <input 
                         type="number"
                         value={editingTask.elapsed || 0}
                         onChange={e => setEditingTask({...editingTask, elapsed: Number(e.target.value)})}
                         className="w-full px-3 py-2 rounded-lg border border-slate-200 outline-none font-mono text-slate-700"
                         disabled={editingTask.id === activeTaskId} // 実行中は変更不可
                       />
                     </div>
                  </div>
                </div>
                
                {/* 時間設定 (スケジュール & ポイント) */}
                <div className="bg-blue-50/50 p-4 rounded-xl border border-blue-100 space-y-4">
                  <h4 className="text-sm font-bold text-blue-600 flex items-center gap-1">
                    <Calendar size={14} /> スケジュール & ポイント設定 (編集可能)
                  </h4>
                  
                  <div className="grid grid-cols-3 gap-4">
                    <div>
                      <label className="block text-xs font-bold text-slate-500 mb-1">開始予定時刻</label>
                      <input 
                        type="time"
                        value={editingTask.scheduledTime}
                        onChange={e => setEditingTask({...editingTask, scheduledTime: e.target.value})}
                        className="w-full px-3 py-2 rounded-lg border border-slate-200 outline-none font-mono"
                      />
                    </div>
                    <div>
                      <label className="block text-xs font-bold text-slate-500 mb-1">見積もり時間 (分)</label>
                      <input 
                        type="number"
                        step="5"
                        min="5"
                        required
                        value={editingTask.estimatedMin}
                        onChange={e => setEditingTask({...editingTask, estimatedMin: Number(e.target.value)})}
                        className="w-full px-3 py-2 rounded-lg border border-slate-200 outline-none font-mono"
                      />
                    </div>
                    <div>
                      <label className="block text-xs font-bold text-slate-500 mb-1">実績時間 (pt)</label>
                      <input 
                        type="number"
                        min="0"
                        value={editingTask.actualMin}
                        onChange={e => setEditingTask({...editingTask, actualMin: Number(e.target.value)})}
                        className={`w-full px-3 py-2 rounded-lg border border-slate-200 outline-none font-mono font-bold ${editingTask.status === 'done' ? 'text-green-600 bg-green-50' : 'text-slate-700'}`}
                      />
                    </div>
                  </div>
                </div>


                {/* KPT (振り返り) */}
                {(editingTask.status === 'done' || editingTask.kpt?.k || editingTask.kpt?.p || editingTask.kpt?.t) && (
                  <div className={`${editingTask.status === 'done' ? 'bg-yellow-100 p-6 shadow-md ring-2 ring-orange-200' : 'bg-yellow-50/50 p-4'} rounded-xl border border-yellow-100 space-y-3 transition-all duration-300`}>
                    <h4 className="text-sm font-bold text-orange-500 flex items-center gap-1">
                      <Star size={14} /> KPT 振り返り
                    </h4>
                    <input 
                      placeholder="Keep: 良かったこと (継続)"
                      value={editingTask.kpt?.k || ''}
                      onChange={e => setEditingTask({...editingTask, kpt: {...editingTask.kpt, k: e.target.value}})}
                      className="w-full px-3 py-2 rounded border border-orange-200/50 text-sm focus:bg-white transition-colors"
                    />
                    <input 
                      placeholder="Problem: 課題 (改善点)"
                      value={editingTask.kpt?.p || ''}
                      onChange={e => setEditingTask({...editingTask, kpt: {...editingTask.kpt, p: e.target.value}})}
                      className="w-full px-3 py-2 rounded border border-blue-200/50 text-sm focus:bg-white transition-colors"
                    />
                    <input 
                      placeholder="Try: 次やること (挑戦)"
                      value={editingTask.kpt?.t || ''}
                      onChange={e => setEditingTask({...editingTask, kpt: {...editingTask.kpt, t: e.target.value}})}
                      className="w-full px-3 py-2 rounded border border-green-200/50 text-sm focus:bg-white transition-colors"
                    />
                  </div>
                )}

              </form>
            </div>

            {/* モーダルフッター */}
            <div className="p-4 border-t border-slate-100 bg-slate-50 flex justify-between items-center gap-4 flex-shrink-0">
              <div className="flex gap-2">
                {editingTask.id && (
                  <button 
                    type="button" 
                    onClick={() => setIsDeleteConfirmOpen(true)}
                    className="text-red-400 hover:text-red-600 p-2 rounded hover:bg-red-50 transition-colors"
                    title="タスクを削除"
                  >
                    <Trash2 size={18} />
                  </button>
                )}
                {editingTask.status === 'done' && (
                  <button 
                    type="button" 
                    onClick={() => resetTask(editingTask.id)}
                    className="text-blue-400 hover:text-blue-600 p-2 rounded hover:bg-blue-50 transition-colors flex items-center gap-1 text-sm font-bold"
                    title="タスクを未完了に戻す"
                  >
                    <RotateCcw size={14} /> リセット
                  </button>
                )}
              </div>
              <div className="flex gap-3 flex-1 justify-end">
                <button 
                  type="submit" 
                  form="taskForm"
                  className="px-6 py-2 rounded-lg font-bold text-white bg-blue-600 hover:bg-blue-700 shadow-lg active:scale-95 transition-all flex items-center gap-2"
                >
                  <Save size={16} /> 保存する
                </button>
              </div>
            </div>

          </div>
        </div>
      )}
      
      {/* 2. KPT入力専用モーダル (完了直後のみ) */}
      {isKptModalOpen && completingTask && (
        <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-slate-900/60 backdrop-blur-sm animate-fade-in">
          <div className="bg-white rounded-2xl shadow-2xl w-full max-w-lg overflow-hidden animate-slide-up">
            <div className="bg-gradient-to-r from-green-500 to-emerald-600 px-6 py-4 flex justify-between items-center text-white">
              <div className="flex items-center gap-2">
                <CheckCircle className="animate-bounce" />
                <h3 className="font-bold text-lg">タスク完了！振り返りましょう</h3>
              </div>
            </div>
            
            <div className="p-6">
              <div className="flex items-center justify-between mb-6 bg-green-50 p-3 rounded-lg border border-green-100">
                <div className="text-center w-1/3 border-r border-green-200">
                  <div className="text-xs text-slate-400 mb-1">見積もり</div>
                  <div className="font-bold text-slate-700">{completingTask?.estimatedMin} 分</div>
                </div>
                <div className="text-center w-1/3">
                  <div className="text-xs text-slate-400 mb-1">実績時間</div>
                  <div className="font-bold text-xl text-green-600">
                    {completingTask?.actualMin} <span className="text-sm font-normal">分</span>
                  </div>
                </div>
                <div className="text-center w-1/3 border-l border-green-200">
                  <div className="text-xs text-slate-400 mb-1">獲得ポイント</div>
                  <div className="font-bold text-orange-500 text-xl">
                    +{completingTask?.actualMin} pt
                  </div>
                </div>
              </div>

              <div className="space-y-4">
                {/* KPT入力フィールド */}
                <div>
                  <label className="flex items-center gap-2 text-sm font-bold text-orange-500 mb-1">
                    <span className="bg-orange-100 px-2 rounded">K</span> Keep (良かったこと)
                  </label>
                  <input 
                    className="w-full px-3 py-2 border border-orange-200 rounded-lg focus:ring-2 focus:ring-orange-100 outline-none"
                    placeholder="例: 集中して一気に終わらせられた"
                    value={completingTask.kpt.k}
                    onChange={e => setCompletingTask({...completingTask, kpt: {...completingTask.kpt, k: e.target.value}})}
                  />
                </div>
                <div>
                  <label className="flex items-center gap-2 text-sm font-bold text-blue-500 mb-1">
                    <span className="bg-blue-100 px-2 rounded">P</span> Problem (課題・悪かったこと)
                  </label>
                  <input 
                    className="w-full px-3 py-2 border border-blue-200 rounded-lg focus:ring-2 focus:ring-blue-100 outline-none"
                    placeholder="例: 資料探しに時間がかかった"
                    value={completingTask.kpt.p}
                    onChange={e => setCompletingTask({...completingTask, kpt: {...completingTask.kpt, p: e.target.value}})}
                  />
                </div>
                <div>
                  <label className="flex items-center gap-2 text-sm font-bold text-green-500 mb-1">
                    <span className="bg-green-100 px-2 rounded">T</span> Try (次やること)
                  </label>
                  <input 
                    className="w-full px-3 py-2 border border-green-200 rounded-lg focus:ring-2 focus:ring-green-100 outline-none"
                    placeholder="例: 事前に必要なURLをまとめておく"
                    value={completingTask.kpt.t}
                    onChange={e => setCompletingTask({...completingTask, kpt: {...completingTask.kpt, t: e.target.value}})}
                  />
                </div>
              </div>

              <div className="mt-8 flex gap-3">
                 <button 
                  onClick={() => finalizeKpt(completingTask.kpt)}
                  className="flex-1 bg-slate-100 text-slate-500 font-bold py-3 rounded-xl hover:bg-slate-200 transition-colors"
                >
                  KPTなしで確定
                </button>
                <button 
                  onClick={() => finalizeKpt(completingTask.kpt)}
                  className="flex-[2] bg-gradient-to-r from-green-500 to-emerald-600 text-white font-bold py-3 rounded-xl shadow-lg hover:shadow-xl hover:scale-[1.02] transition-all flex items-center justify-center gap-2"
                >
                  <Save size={18} /> 記録してポイント確定
                </button>
              </div>
            </div>
          </div>
        </div>
      )}
      
      {/* 3. 目標設定モーダル */}
      {isGoalModalOpen && (
        <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-slate-900/60 backdrop-blur-sm animate-fade-in">
          <div className="bg-white rounded-2xl shadow-xl w-full max-w-sm p-6 text-center">
            <div className="w-16 h-16 bg-orange-100 text-orange-500 rounded-full flex items-center justify-center mx-auto mb-4">
              <Trophy size={32} />
            </div>
            <h3 className="text-xl font-bold text-slate-800 mb-2">今日の目標を設定</h3>
            <p className="text-slate-500 text-sm mb-6">
              1分 ＝ 1ポイントです。<br/>今日どれくらいタスクに集中しますか？
            </p>
            
            <div className="flex flex-wrap justify-center gap-3 mb-6">
              {[60, 120, 180, 240, 300].map(pt => (
                <button
                  key={pt}
                  onClick={() => setTargetPoints(pt)}
                  className={`px-4 py-2 rounded-lg font-bold border transition-all ${
                    targetPoints === pt 
                      ? 'bg-orange-500 text-white border-orange-500 shadow-md transform scale-105' 
                      : 'bg-white text-slate-600 border-slate-200 hover:bg-slate-50'
                  }`}
                >
                  {pt}分
                </button>
              ))}
            </div>
            <div className="flex items-center justify-center gap-2 mb-6">
               <span className="text-sm font-bold text-slate-500">カスタム:</span>
               <input 
                 type="number" 
                 value={targetPoints}
                 onChange={(e) => setTargetPoints(Number(e.target.value))}
                 className="w-24 text-center border-b-2 border-slate-200 focus:border-orange-500 outline-none font-bold text-lg"
                 min="1"
               />
               <span className="text-sm font-bold text-slate-500">pt</span>
            </div>

            <button 
              onClick={() => setIsGoalModalOpen(false)}
              className="w-full bg-slate-800 text-white font-bold py-3 rounded-xl shadow-lg hover:shadow-xl hover:scale-[1.02] transition-all"
            >
              設定してスタート！
            </button>
          </div>
        </div>
      )}
      
      {/* 4. 削除確認モーダル */}
      {isDeleteConfirmOpen && editingTask && (
        <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-slate-900/40 backdrop-blur-sm animate-fade-in">
          <div className="bg-white rounded-2xl shadow-2xl w-full max-w-sm overflow-hidden animate-slide-up p-6 text-center">
            <div className="w-16 h-16 bg-red-100 text-red-500 rounded-full flex items-center justify-center mx-auto mb-4">
              <AlertTriangle size={32} />
            </div>
            <h3 className="text-lg font-bold text-slate-800 mb-2">タスクを削除しますか？</h3>
            <p className="text-slate-500 text-sm mb-6">
              「{editingTask.title}」をリストとタイムラインから完全に削除します。
            </p>
            <div className="flex gap-3">
              <button 
                onClick={() => setIsDeleteConfirmOpen(false)}
                className="flex-1 bg-slate-100 text-slate-600 font-bold py-2.5 rounded-xl hover:bg-slate-200 transition-colors"
              >
                キャンセル
              </button>
              <button 
                onClick={() => {
                  setTasks(tasks.filter(t => t.id !== editingTask.id));
                  if (activeTaskId === editingTask.id) setActiveTaskId(null);
                  closeEditModal();
                  setIsDeleteConfirmOpen(false);
                }}
                className="flex-1 bg-red-500 text-white font-bold py-2.5 rounded-xl hover:bg-red-600 shadow-md transition-colors"
              >
                削除する
              </button>
            </div>
          </div>
        </div>
      )}
      
      <style>{`
        .animate-fade-in {
          animation: fadeIn 0.3s ease-out;
        }
        .animate-slide-up {
          animation: slideUp 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        .animate-confetti {
            animation: bounce 5s infinite;
        }
        @keyframes fadeIn {
          from { opacity: 0; }
          to { opacity: 1; }
        }
        @keyframes slideUp {
          from { transform: translateY(20px); opacity: 0; }
          to { transform: translateY(0); opacity: 1; }
        }
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {transform: translateY(0);}
            40% {transform: translateY(-30px);}
            60% {transform: translateY(-15px);}
        }
        /* Custom Scrollbar for better visibility */
        .custom-scrollbar::-webkit-scrollbar {
          width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
          background-color: #cbd5e1; /* slate-300 */
          border-radius: 4px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
          background: #f1f5f9; /* slate-100 */
        }
      `}</style>
    </div>
  );
};

export default ActionBoard;